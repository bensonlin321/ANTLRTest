# Generated from grammar/pockets.g4 by ANTLR 4.9.3
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3#")
        buf.write("\u009c\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\3\2\3\2\6\2%\n\2\r")
        buf.write("\2\16\2&\3\2\3\2\3\3\3\3\3\3\3\3\5\3/\n\3\3\4\3\4\3\4")
        buf.write("\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\7\5=\n\5\f\5\16\5")
        buf.write("@\13\5\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\7\5\7K\n\7\3")
        buf.write("\b\3\b\3\b\3\b\7\bQ\n\b\f\b\16\bT\13\b\3\b\3\b\3\t\3\t")
        buf.write("\3\t\3\t\3\n\3\n\3\n\7\n_\n\n\f\n\16\nb\13\n\3\13\3\13")
        buf.write("\3\13\7\13g\n\13\f\13\16\13j\13\13\3\f\3\f\3\f\3\f\3\f")
        buf.write("\3\f\3\f\3\f\3\f\3\f\3\f\7\fw\n\f\f\f\16\fz\13\f\3\r\3")
        buf.write("\r\3\16\3\16\3\16\5\16\u0081\n\16\3\17\3\17\3\17\3\17")
        buf.write("\5\17\u0087\n\17\3\20\3\20\3\20\5\20\u008c\n\20\3\20\3")
        buf.write("\20\5\20\u0090\n\20\3\20\3\20\6\20\u0094\n\20\r\20\16")
        buf.write("\20\u0095\5\20\u0098\n\20\3\21\3\21\3\21\2\3\26\22\2\4")
        buf.write("\6\b\n\f\16\20\22\24\26\30\32\34\36 \2\4\4\2\24\24\30")
        buf.write("\34\3\2\26\27\2\u00a1\2$\3\2\2\2\4.\3\2\2\2\6\60\3\2\2")
        buf.write("\2\b\64\3\2\2\2\nA\3\2\2\2\fD\3\2\2\2\16L\3\2\2\2\20W")
        buf.write("\3\2\2\2\22[\3\2\2\2\24c\3\2\2\2\26k\3\2\2\2\30{\3\2\2")
        buf.write("\2\32\u0080\3\2\2\2\34\u0086\3\2\2\2\36\u0097\3\2\2\2")
        buf.write(" \u0099\3\2\2\2\"%\5\4\3\2#%\7\3\2\2$\"\3\2\2\2$#\3\2")
        buf.write("\2\2%&\3\2\2\2&$\3\2\2\2&\'\3\2\2\2\'(\3\2\2\2()\7\2\2")
        buf.write("\3)\3\3\2\2\2*/\5\6\4\2+/\5\b\5\2,/\5\n\6\2-/\5\f\7\2")
        buf.write(".*\3\2\2\2.+\3\2\2\2.,\3\2\2\2.-\3\2\2\2/\5\3\2\2\2\60")
        buf.write("\61\7\4\2\2\61\62\5 \21\2\62\63\5\16\b\2\63\7\3\2\2\2")
        buf.write("\64\65\7\7\2\2\65\66\7\b\2\2\66\67\5 \21\2\678\5\16\b")
        buf.write("\289\7\t\2\29>\5\20\t\2:;\7\20\2\2;=\5\20\t\2<:\3\2\2")
        buf.write("\2=@\3\2\2\2><\3\2\2\2>?\3\2\2\2?\t\3\2\2\2@>\3\2\2\2")
        buf.write("AB\7\r\2\2BC\5 \21\2C\13\3\2\2\2DE\7\5\2\2EF\5\24\13\2")
        buf.write("FG\7\6\2\2GJ\5 \21\2HI\7\f\2\2IK\5\26\f\2JH\3\2\2\2JK")
        buf.write("\3\2\2\2K\r\3\2\2\2LM\7\22\2\2MR\5\34\17\2NO\7\20\2\2")
        buf.write("OQ\5\34\17\2PN\3\2\2\2QT\3\2\2\2RP\3\2\2\2RS\3\2\2\2S")
        buf.write("U\3\2\2\2TR\3\2\2\2UV\7\23\2\2V\17\3\2\2\2WX\7\22\2\2")
        buf.write("XY\5\22\n\2YZ\7\23\2\2Z\21\3\2\2\2[`\5\36\20\2\\]\7\20")
        buf.write("\2\2]_\5\36\20\2^\\\3\2\2\2_b\3\2\2\2`^\3\2\2\2`a\3\2")
        buf.write("\2\2a\23\3\2\2\2b`\3\2\2\2ch\5\32\16\2de\7\20\2\2eg\5")
        buf.write("\32\16\2fd\3\2\2\2gj\3\2\2\2hf\3\2\2\2hi\3\2\2\2i\25\3")
        buf.write("\2\2\2jh\3\2\2\2kl\b\f\1\2lm\5\34\17\2mn\5\30\r\2no\5")
        buf.write("\32\16\2ox\3\2\2\2pq\f\4\2\2qr\7\35\2\2rw\5\26\f\5st\f")
        buf.write("\3\2\2tu\7\36\2\2uw\5\26\f\4vp\3\2\2\2vs\3\2\2\2wz\3\2")
        buf.write("\2\2xv\3\2\2\2xy\3\2\2\2y\27\3\2\2\2zx\3\2\2\2{|\t\2\2")
        buf.write("\2|\31\3\2\2\2}\u0081\7\21\2\2~\u0081\5\34\17\2\177\u0081")
        buf.write("\5\36\20\2\u0080}\3\2\2\2\u0080~\3\2\2\2\u0080\177\3\2")
        buf.write("\2\2\u0081\33\3\2\2\2\u0082\u0083\7\"\2\2\u0083\u0084")
        buf.write("\7\17\2\2\u0084\u0087\7\"\2\2\u0085\u0087\7\"\2\2\u0086")
        buf.write("\u0082\3\2\2\2\u0086\u0085\3\2\2\2\u0087\35\3\2\2\2\u0088")
        buf.write("\u0098\7\16\2\2\u0089\u0098\5\34\17\2\u008a\u008c\t\3")
        buf.write("\2\2\u008b\u008a\3\2\2\2\u008b\u008c\3\2\2\2\u008c\u008d")
        buf.write("\3\2\2\2\u008d\u0098\7 \2\2\u008e\u0090\t\3\2\2\u008f")
        buf.write("\u008e\3\2\2\2\u008f\u0090\3\2\2\2\u0090\u0091\3\2\2\2")
        buf.write("\u0091\u0098\7!\2\2\u0092\u0094\7\37\2\2\u0093\u0092\3")
        buf.write("\2\2\2\u0094\u0095\3\2\2\2\u0095\u0093\3\2\2\2\u0095\u0096")
        buf.write("\3\2\2\2\u0096\u0098\3\2\2\2\u0097\u0088\3\2\2\2\u0097")
        buf.write("\u0089\3\2\2\2\u0097\u008b\3\2\2\2\u0097\u008f\3\2\2\2")
        buf.write("\u0097\u0093\3\2\2\2\u0098\37\3\2\2\2\u0099\u009a\5\34")
        buf.write("\17\2\u009a!\3\2\2\2\22$&.>JR`hvx\u0080\u0086\u008b\u008f")
        buf.write("\u0095\u0097")
        return buf.getvalue()


class pocketsParser ( Parser ):

    grammarFileName = "pockets.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'.'", "','", "'*'", "'('", "')'", "'='", "'!'", "'-'", 
                     "'+'", "'>'", "'>='", "'<'", "'<='", "'!='" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "CREATE", "SELECT", "FROM", 
                      "INSERT", "INTO", "ROWS", "UPDATE", "SET", "WHERE", 
                      "DELETE", "NULL", "DOT", "COMMA", "ASTERISK", "LEFT_PARENTHESIS", 
                      "RIGHT_PARENTHESIS", "EQUALS", "NOT", "MINUS", "PLUS", 
                      "GT", "GE", "LT", "LE", "NE", "AND", "OR", "QUOTED_STRING", 
                      "INTEGER_VALUE", "DECIMAL_VALUE", "IDENTIFIER", "WS" ]

    RULE_pocket = 0
    RULE_statement = 1
    RULE_create = 2
    RULE_insert = 3
    RULE_delete = 4
    RULE_select = 5
    RULE_columnNames = 6
    RULE_values = 7
    RULE_constants = 8
    RULE_expressionList = 9
    RULE_booleanExpression = 10
    RULE_compare = 11
    RULE_expression = 12
    RULE_identifier = 13
    RULE_constant = 14
    RULE_fileIdentifier = 15

    ruleNames =  [ "pocket", "statement", "create", "insert", "delete", 
                   "select", "columnNames", "values", "constants", "expressionList", 
                   "booleanExpression", "compare", "expression", "identifier", 
                   "constant", "fileIdentifier" ]

    EOF = Token.EOF
    T__0=1
    CREATE=2
    SELECT=3
    FROM=4
    INSERT=5
    INTO=6
    ROWS=7
    UPDATE=8
    SET=9
    WHERE=10
    DELETE=11
    NULL=12
    DOT=13
    COMMA=14
    ASTERISK=15
    LEFT_PARENTHESIS=16
    RIGHT_PARENTHESIS=17
    EQUALS=18
    NOT=19
    MINUS=20
    PLUS=21
    GT=22
    GE=23
    LT=24
    LE=25
    NE=26
    AND=27
    OR=28
    QUOTED_STRING=29
    INTEGER_VALUE=30
    DECIMAL_VALUE=31
    IDENTIFIER=32
    WS=33

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class PocketContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(pocketsParser.EOF, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(pocketsParser.StatementContext)
            else:
                return self.getTypedRuleContext(pocketsParser.StatementContext,i)


        def getRuleIndex(self):
            return pocketsParser.RULE_pocket

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPocket" ):
                listener.enterPocket(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPocket" ):
                listener.exitPocket(self)




    def pocket(self):

        localctx = pocketsParser.PocketContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_pocket)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 34 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 34
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [pocketsParser.CREATE, pocketsParser.SELECT, pocketsParser.INSERT, pocketsParser.DELETE]:
                    self.state = 32
                    self.statement()
                    pass
                elif token in [pocketsParser.T__0]:
                    self.state = 33
                    self.match(pocketsParser.T__0)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 36 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << pocketsParser.T__0) | (1 << pocketsParser.CREATE) | (1 << pocketsParser.SELECT) | (1 << pocketsParser.INSERT) | (1 << pocketsParser.DELETE))) != 0)):
                    break

            self.state = 38
            self.match(pocketsParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def create(self):
            return self.getTypedRuleContext(pocketsParser.CreateContext,0)


        def insert(self):
            return self.getTypedRuleContext(pocketsParser.InsertContext,0)


        def delete(self):
            return self.getTypedRuleContext(pocketsParser.DeleteContext,0)


        def select(self):
            return self.getTypedRuleContext(pocketsParser.SelectContext,0)


        def getRuleIndex(self):
            return pocketsParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = pocketsParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 44
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [pocketsParser.CREATE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 40
                self.create()
                pass
            elif token in [pocketsParser.INSERT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 41
                self.insert()
                pass
            elif token in [pocketsParser.DELETE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 42
                self.delete()
                pass
            elif token in [pocketsParser.SELECT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 43
                self.select()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE(self):
            return self.getToken(pocketsParser.CREATE, 0)

        def fileIdentifier(self):
            return self.getTypedRuleContext(pocketsParser.FileIdentifierContext,0)


        def columnNames(self):
            return self.getTypedRuleContext(pocketsParser.ColumnNamesContext,0)


        def getRuleIndex(self):
            return pocketsParser.RULE_create

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate" ):
                listener.enterCreate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate" ):
                listener.exitCreate(self)




    def create(self):

        localctx = pocketsParser.CreateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_create)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 46
            self.match(pocketsParser.CREATE)
            self.state = 47
            self.fileIdentifier()
            self.state = 48
            self.columnNames()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InsertContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INSERT(self):
            return self.getToken(pocketsParser.INSERT, 0)

        def INTO(self):
            return self.getToken(pocketsParser.INTO, 0)

        def fileIdentifier(self):
            return self.getTypedRuleContext(pocketsParser.FileIdentifierContext,0)


        def columnNames(self):
            return self.getTypedRuleContext(pocketsParser.ColumnNamesContext,0)


        def ROWS(self):
            return self.getToken(pocketsParser.ROWS, 0)

        def values(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(pocketsParser.ValuesContext)
            else:
                return self.getTypedRuleContext(pocketsParser.ValuesContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(pocketsParser.COMMA)
            else:
                return self.getToken(pocketsParser.COMMA, i)

        def getRuleIndex(self):
            return pocketsParser.RULE_insert

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsert" ):
                listener.enterInsert(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsert" ):
                listener.exitInsert(self)




    def insert(self):

        localctx = pocketsParser.InsertContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_insert)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 50
            self.match(pocketsParser.INSERT)
            self.state = 51
            self.match(pocketsParser.INTO)
            self.state = 52
            self.fileIdentifier()
            self.state = 53
            self.columnNames()
            self.state = 54
            self.match(pocketsParser.ROWS)
            self.state = 55
            self.values()
            self.state = 60
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==pocketsParser.COMMA:
                self.state = 56
                self.match(pocketsParser.COMMA)
                self.state = 57
                self.values()
                self.state = 62
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeleteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELETE(self):
            return self.getToken(pocketsParser.DELETE, 0)

        def fileIdentifier(self):
            return self.getTypedRuleContext(pocketsParser.FileIdentifierContext,0)


        def getRuleIndex(self):
            return pocketsParser.RULE_delete

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelete" ):
                listener.enterDelete(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelete" ):
                listener.exitDelete(self)




    def delete(self):

        localctx = pocketsParser.DeleteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_delete)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self.match(pocketsParser.DELETE)
            self.state = 64
            self.fileIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(pocketsParser.SELECT, 0)

        def expressionList(self):
            return self.getTypedRuleContext(pocketsParser.ExpressionListContext,0)


        def FROM(self):
            return self.getToken(pocketsParser.FROM, 0)

        def fileIdentifier(self):
            return self.getTypedRuleContext(pocketsParser.FileIdentifierContext,0)


        def WHERE(self):
            return self.getToken(pocketsParser.WHERE, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(pocketsParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return pocketsParser.RULE_select

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect" ):
                listener.enterSelect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect" ):
                listener.exitSelect(self)




    def select(self):

        localctx = pocketsParser.SelectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_select)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 66
            self.match(pocketsParser.SELECT)
            self.state = 67
            self.expressionList()
            self.state = 68
            self.match(pocketsParser.FROM)
            self.state = 69
            self.fileIdentifier()
            self.state = 72
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==pocketsParser.WHERE:
                self.state = 70
                self.match(pocketsParser.WHERE)
                self.state = 71
                self.booleanExpression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnNamesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(pocketsParser.LEFT_PARENTHESIS, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(pocketsParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(pocketsParser.IdentifierContext,i)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(pocketsParser.RIGHT_PARENTHESIS, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(pocketsParser.COMMA)
            else:
                return self.getToken(pocketsParser.COMMA, i)

        def getRuleIndex(self):
            return pocketsParser.RULE_columnNames

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnNames" ):
                listener.enterColumnNames(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnNames" ):
                listener.exitColumnNames(self)




    def columnNames(self):

        localctx = pocketsParser.ColumnNamesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_columnNames)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self.match(pocketsParser.LEFT_PARENTHESIS)
            self.state = 75
            self.identifier()
            self.state = 80
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==pocketsParser.COMMA:
                self.state = 76
                self.match(pocketsParser.COMMA)
                self.state = 77
                self.identifier()
                self.state = 82
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 83
            self.match(pocketsParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValuesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(pocketsParser.LEFT_PARENTHESIS, 0)

        def constants(self):
            return self.getTypedRuleContext(pocketsParser.ConstantsContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(pocketsParser.RIGHT_PARENTHESIS, 0)

        def getRuleIndex(self):
            return pocketsParser.RULE_values

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValues" ):
                listener.enterValues(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValues" ):
                listener.exitValues(self)




    def values(self):

        localctx = pocketsParser.ValuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_values)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 85
            self.match(pocketsParser.LEFT_PARENTHESIS)
            self.state = 86
            self.constants()
            self.state = 87
            self.match(pocketsParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(pocketsParser.ConstantContext)
            else:
                return self.getTypedRuleContext(pocketsParser.ConstantContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(pocketsParser.COMMA)
            else:
                return self.getToken(pocketsParser.COMMA, i)

        def getRuleIndex(self):
            return pocketsParser.RULE_constants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstants" ):
                listener.enterConstants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstants" ):
                listener.exitConstants(self)




    def constants(self):

        localctx = pocketsParser.ConstantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_constants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 89
            self.constant()
            self.state = 94
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==pocketsParser.COMMA:
                self.state = 90
                self.match(pocketsParser.COMMA)
                self.state = 91
                self.constant()
                self.state = 96
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(pocketsParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(pocketsParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(pocketsParser.COMMA)
            else:
                return self.getToken(pocketsParser.COMMA, i)

        def getRuleIndex(self):
            return pocketsParser.RULE_expressionList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionList" ):
                listener.enterExpressionList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionList" ):
                listener.exitExpressionList(self)




    def expressionList(self):

        localctx = pocketsParser.ExpressionListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_expressionList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self.expression()
            self.state = 102
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==pocketsParser.COMMA:
                self.state = 98
                self.match(pocketsParser.COMMA)
                self.state = 99
                self.expression()
                self.state = 104
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.left = None # BooleanExpressionContext
            self.operator = None # Token
            self.right = None # BooleanExpressionContext

        def identifier(self):
            return self.getTypedRuleContext(pocketsParser.IdentifierContext,0)


        def compare(self):
            return self.getTypedRuleContext(pocketsParser.CompareContext,0)


        def expression(self):
            return self.getTypedRuleContext(pocketsParser.ExpressionContext,0)


        def booleanExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(pocketsParser.BooleanExpressionContext)
            else:
                return self.getTypedRuleContext(pocketsParser.BooleanExpressionContext,i)


        def AND(self):
            return self.getToken(pocketsParser.AND, 0)

        def OR(self):
            return self.getToken(pocketsParser.OR, 0)

        def getRuleIndex(self):
            return pocketsParser.RULE_booleanExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanExpression" ):
                listener.enterBooleanExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanExpression" ):
                listener.exitBooleanExpression(self)



    def booleanExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = pocketsParser.BooleanExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 20
        self.enterRecursionRule(localctx, 20, self.RULE_booleanExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 106
            self.identifier()
            self.state = 107
            self.compare()
            self.state = 108
            self.expression()
            self._ctx.stop = self._input.LT(-1)
            self.state = 118
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 116
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
                    if la_ == 1:
                        localctx = pocketsParser.BooleanExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 110
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 111
                        localctx.operator = self.match(pocketsParser.AND)
                        self.state = 112
                        localctx.right = self.booleanExpression(3)
                        pass

                    elif la_ == 2:
                        localctx = pocketsParser.BooleanExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 113
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 114
                        localctx.operator = self.match(pocketsParser.OR)
                        self.state = 115
                        localctx.right = self.booleanExpression(2)
                        pass

             
                self.state = 120
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class CompareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUALS(self):
            return self.getToken(pocketsParser.EQUALS, 0)

        def GT(self):
            return self.getToken(pocketsParser.GT, 0)

        def GE(self):
            return self.getToken(pocketsParser.GE, 0)

        def LT(self):
            return self.getToken(pocketsParser.LT, 0)

        def LE(self):
            return self.getToken(pocketsParser.LE, 0)

        def NE(self):
            return self.getToken(pocketsParser.NE, 0)

        def getRuleIndex(self):
            return pocketsParser.RULE_compare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompare" ):
                listener.enterCompare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompare" ):
                listener.exitCompare(self)




    def compare(self):

        localctx = pocketsParser.CompareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_compare)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << pocketsParser.EQUALS) | (1 << pocketsParser.GT) | (1 << pocketsParser.GE) | (1 << pocketsParser.LT) | (1 << pocketsParser.LE) | (1 << pocketsParser.NE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASTERISK(self):
            return self.getToken(pocketsParser.ASTERISK, 0)

        def identifier(self):
            return self.getTypedRuleContext(pocketsParser.IdentifierContext,0)


        def constant(self):
            return self.getTypedRuleContext(pocketsParser.ConstantContext,0)


        def getRuleIndex(self):
            return pocketsParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)




    def expression(self):

        localctx = pocketsParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_expression)
        try:
            self.state = 126
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 123
                self.match(pocketsParser.ASTERISK)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 124
                self.identifier()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 125
                self.constant()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(pocketsParser.IDENTIFIER)
            else:
                return self.getToken(pocketsParser.IDENTIFIER, i)

        def DOT(self):
            return self.getToken(pocketsParser.DOT, 0)

        def getRuleIndex(self):
            return pocketsParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = pocketsParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_identifier)
        try:
            self.state = 132
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 128
                self.match(pocketsParser.IDENTIFIER)
                self.state = 129
                self.match(pocketsParser.DOT)
                self.state = 130
                self.match(pocketsParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 131
                self.match(pocketsParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NULL(self):
            return self.getToken(pocketsParser.NULL, 0)

        def identifier(self):
            return self.getTypedRuleContext(pocketsParser.IdentifierContext,0)


        def INTEGER_VALUE(self):
            return self.getToken(pocketsParser.INTEGER_VALUE, 0)

        def MINUS(self):
            return self.getToken(pocketsParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(pocketsParser.PLUS, 0)

        def DECIMAL_VALUE(self):
            return self.getToken(pocketsParser.DECIMAL_VALUE, 0)

        def QUOTED_STRING(self, i:int=None):
            if i is None:
                return self.getTokens(pocketsParser.QUOTED_STRING)
            else:
                return self.getToken(pocketsParser.QUOTED_STRING, i)

        def getRuleIndex(self):
            return pocketsParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)




    def constant(self):

        localctx = pocketsParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_constant)
        self._la = 0 # Token type
        try:
            self.state = 149
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 134
                self.match(pocketsParser.NULL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 135
                self.identifier()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 137
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==pocketsParser.MINUS or _la==pocketsParser.PLUS:
                    self.state = 136
                    _la = self._input.LA(1)
                    if not(_la==pocketsParser.MINUS or _la==pocketsParser.PLUS):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 139
                self.match(pocketsParser.INTEGER_VALUE)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 141
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==pocketsParser.MINUS or _la==pocketsParser.PLUS:
                    self.state = 140
                    _la = self._input.LA(1)
                    if not(_la==pocketsParser.MINUS or _la==pocketsParser.PLUS):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 143
                self.match(pocketsParser.DECIMAL_VALUE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 145 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 144
                        self.match(pocketsParser.QUOTED_STRING)

                    else:
                        raise NoViableAltException(self)
                    self.state = 147 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def identifier(self):
            return self.getTypedRuleContext(pocketsParser.IdentifierContext,0)


        def getRuleIndex(self):
            return pocketsParser.RULE_fileIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFileIdentifier" ):
                listener.enterFileIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFileIdentifier" ):
                listener.exitFileIdentifier(self)




    def fileIdentifier(self):

        localctx = pocketsParser.FileIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_fileIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            localctx.name = self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[10] = self.booleanExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def booleanExpression_sempred(self, localctx:BooleanExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 1)
         




